/*************************
 * Check and Radio items *
 *************************/
// draw regular check and radio items using our PNG assets
// all assets are rendered from assets.svg. never add pngs directly


//selection-mode
@each $check_state, $check_icon, $check_color, $check_background in
  ('', 'none', 'transparent', $checkradio_bg_color),
  (':hover', 'none', 'transparent', $checkradio_bg_color),
  (':active', 'none', 'transparent', $checkradio_bg_color),
  (':backdrop', 'none', 'transparent', '#{desaturate($checkradio_bg_color, 100%)}'),
  (':checked', '-gtk-icontheme(\'object-select-symbolic\')', $osd_fg_color, $checkradio_bg_color),
  (':checked:hover', '-gtk-icontheme(\'object-select-symbolic\')', $osd_fg_color, $checkradio_bg_color),
  (':checked:active', '-gtk-icontheme(\'object-select-symbolic\')', $osd_fg_color, $checkradio_bg_color),
  (':backdrop:checked', '-gtk-icontheme(\'object-select-symbolic\')', '#{transparentize($osd_fg_color, 0.2)}', '#{desaturate($checkradio_bg_color, 100%)}'), {

  .view.content-view.check#{$check_state}:not(list),
  .content-view:not(list) check#{$check_state} {
    margin: 4px;
    min-width: 32px;
    min-height: 32px;
    color: #{$check_color};
    background-color: #{$check_background};
    border-radius: 5px;
    background-image: none;
    transition: 200ms;
    box-shadow: none;
    border-width: 0;
    -gtk-icon-source: #{$check_icon};
    -gtk-icon-shadow: none;
  }
}

checkbutton.text-button, radiobutton.text-button {
  // this is for a nice focus on check and radios text
  padding: 2px 0;
  outline-offset: 0;

  label:not(:only-child) {
    &:first-child { margin-left: 4px; }
    &:last-child { margin-right: 4px; }
  }
}

check,
radio {
  margin: 0 4px;

  &:only-child { margin: 0; }

  popover & { // when in a popover add more space between the label and the check, reset the other side margin.
              // See https://bugzilla.gnome.org/show_bug.cgi?id=779570 for details.
    &.left:dir(rtl) {
      margin-left: 0;
      margin-right: 12px;
    }

    &.right:dir(ltr) {
      margin-left: 12px;
      margin-right: 0;
    }
  }

  min-height: 14px;
  min-width: 14px;
  border: 1px solid;
  -gtk-icon-source: none;

  & {
    // for unchecked
    $_c: if($variant=='light', white, $bg_color);

    @each $state, $t in ("", "normal"),
                        (":hover", "hover"),
                        (":active", "active"),
                        (":disabled", "insensitive"),
                        (":backdrop", "backdrop"),
                        (":backdrop:disabled", 'backdrop-insensitive') {
      &#{$state} {
        @include check($t, $_c);
      }
    }
  }

  & {
    // for checked
    @each $t in (':checked'), (':indeterminate') {
      &#{$t} {
        @each $state, $t in ("", "normal"),
                            (":hover", "hover"),
                            (":active", "active"),
                            (":disabled", "insensitive"),
                            (":backdrop", "backdrop"),
                            (":backdrop:disabled", 'backdrop-insensitive') {
          &#{$state} {
            @include check($t, $checkradio_bg_color, $checkradio_fg_color, $checked: true);
          }
        }
      }
    }
  }

  &:backdrop { transition: $backdrop_transition; }

  @if $variant == 'light' {
    // the borders of the light variant versions of checks and radios are too similar in luminosity to the selected background
    // color, hence we need special casing.
    row:selected & { border-color: $checkradio_borders_color; }
  }

  .osd & {
    @include button(osd);

    &:hover { @include button(osd); }
    &:active { @include button(osd-active); }
    &:backdrop { @include button(osd-backdrop); }
    &:disabled { @include button(osd-insensitive); }
  }

  menu menuitem & {
    margin: 0; // this is a workaround for a menu check/radio size allocation issue

    &, &:checked, &:indeterminate {
      &, &:hover, &:disabled { //FIXME use button reset mixin
        min-height: 14px;
        min-width: 14px;
        background-image: none;
        background-color: transparent;
        box-shadow: none;
        -gtk-icon-shadow: none;
        color: inherit;
        border-color: currentColor;
      }
    }
  }
}

%check,
check {
  border-radius: 3px;

  &:checked { -gtk-icon-source: image(-gtk-recolor(url("assets/check-symbolic.svg")),
                                      -gtk-recolor(url("assets/check-symbolic.symbolic.png"))); }

  &:indeterminate { -gtk-icon-source: image(-gtk-recolor(url("assets/dash-symbolic.svg")),
                                            -gtk-recolor(url("assets/dash-symbolic.symbolic.png"))); }
}

%radio,
radio {
  border-radius: 100%;

  &:checked { -gtk-icon-source: image(-gtk-recolor(url("assets/bullet-symbolic.svg")),
                                      -gtk-recolor(url("assets/bullet-symbolic.symbolic.png"))); }

  &:indeterminate { -gtk-icon-source: image(-gtk-recolor(url("assets/dash-symbolic.svg")),
                                            -gtk-recolor(url("assets/dash-symbolic.symbolic.png"))); }
}

// ANIMATION:
// this is made with those pretty convoluted transitions, since checks and radios have to animate only on state changes,
// the transformation is set on the active state and it get reset on the checked state.
radio:not(:indeterminate):not(:checked):active:not(:backdrop) { -gtk-icon-transform: scale(0); }

check:not(:indeterminate):not(:checked):active:not(:backdrop) { -gtk-icon-transform: translate(6px, -3px) rotate(-45deg) scaleY(0.2) rotate(45deg) scaleX(0); }

radio,
check {
  &:active { -gtk-icon-transform: scale(0, 1); } // should tackle the indeterminate state, untested

  &:checked:not(:backdrop), &:indeterminate:not(:backdrop) {
    -gtk-icon-transform: unset;
    transition: 400ms;
  }
}

menu menuitem {
  radio,
  check {
     &:checked:not(:backdrop), &:indeterminate:not(:backdrop) { transition: none; }
  }
}

treeview.view check,
treeview.view radio {
  &:selected {
    &:focus, & {
      color: $checkradio_fg_color;

      @if $variant == 'light' { border-color: $selected_borders_color; }
    }
  }
}

treeview.view radio:selected { &:focus, & { @extend %radio; }} // This is a workaround */
